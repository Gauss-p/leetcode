class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        # 首先我们考虑最基础的情况：n是2的幂。举个例子，如果n=1，那么只需1次就可以将它变成0；如果n=2=(10)_2，那它的变化过程为：10->11->01->00，总共需要3次；如果n=4=(100)_2，那它的变化过程为：100->101->111->110->010->011->001->000，总共需要7次.分析n=4时的变化过程，可以发现在前3次变化中，我们将n的二进制的后两位从00变成了10，且在后3次变化中，我们将n的二进制的后两位从10变成了00，而我们不难发现，从一个数字x变化到0的过程实际上是可逆的，因此我们在将100变为000的过程中，相当于：两次将10变成00，一次将最高位变成0
        # 因此，如果定义f(x)表示将整数x变为0的最少操作次数，那么就有f(4)=2*f(2)+1，以此类推，我们可以得到一个递推式：
        #       f(2**k) = 2*f(2**(k-1))+1
        # 将其两边同加1，可得：
        #       f(2**k)+1 = 2*(f(2**(k-1))+1)
        # 因此不难发现，f(2**k)+1是一个等比数列，且公比为2，同时f(2**0)=f(1)=1
        # 所以可以得到以下公式：f(2**k)+1 = 2**(k+1)，即f(2**k) = 2**(k+1)-1
        # 接下来考虑n不是2的幂的情况。由100变为000的过程可以发现，一个二进制长度为k的数字一定会出现在1<<(k-1)变为0的过程中，因此，为计算一个不是2的幂的数字n变为0的操作次数，如果它的二进制长度为k，我们就相当于在1<<(k-1)变为0的过程中除去1<<(k-1)变为n的总次数，而由于在1<<(k-1)变为n的过程中，最高位并不发生变化，因此我们相当于将0变为n-(1<<(k-1))，又因为这种变化可逆，因此就相当于将n-(1<<(k-1))变为0，即f(n-(1<<(k-1)))
        # 综上可得：f(n) = f(1<<(k-1))+f(n-(1<<(k-1))) (其中k为n的二进制长度)
        # 根据之前的公式可以得到：f(n) = 1<<k - 1 + f(n-(1<<(k-1)))
        # 因此我们可以用递归的方式计算任意一个f(n)，其中递归基为：当n=0时，答案为0
        if n == 0:
            return 0
        k = n.bit_length()
        return (1<<k)-1 - self.minimumOneBitOperations(n-(1<<(k-1)))

if __name__ == "__main__":
    s = Solution()
    n = 3
    print(s.minimumOneBitOperations(n))
