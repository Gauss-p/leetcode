from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        # 根据题意，我们需要将元素变成0，并且每次只能改变最小的非负整数，同时要注意的是，在将某一个值改成0之后，如果要继续改变原比它大的值，就需要以当前位置为界，分成两个部分来运算。
        # 如果将所有的值排列成一个图，可以得到一个类似于山坡的图像，经过观察可以发现，如果要将所有为A的数字都变成0，我们需要在图像上用y=A的直线进行分割，切掉了几个山顶就说明要操作几次
        # ^                                      ^
        # |                      ____           /|
        # |     ___           P /    \___      / |
        # |____/___\___________/_________\_A__/__|____ <---y=A
        # |  _/     \       /             \__/   |
        # | /        \_____/                     |
        # |/_____________________________________|_>
        # 那么为了实现上面的运算，可以采用这样的思路，如果循环到一个数字A，那么我们需要从它开始往前遍历，只要发现一个数字p大于A就说明从p到A进行切割是可以切掉一个山顶的，那么此时就可以累计一个答案，但是只要发现p小于x就必须立刻退出循环，因为切掉的山顶中间不能包括山谷。所以总结而言可以发现我们要求的其实就是一个单调栈，并在每次弹出元素的时候累计一个答案即可
        # 但是需要注意的是边界情况，如果栈为空，我们必须加入当前数字，或者为了防止重复，我们不能加入一个和栈末尾元素相同的元素，所以只有当栈为空或当前数字不等于栈末尾时，我们才能加入当前数字
        # 最后返回答案时需要注意，如果像上面的图那样，最后没有一个下坡，我们是无法在循环中统计出最后一个上坡的答案的，因此在最后需要将栈中剩余非零元素个数加入答案，注意非零
        res = 0
        st = []
        for i in nums:
            while len(st) and st[-1]>i:
                # 维护单调栈
                res += 1
                st.pop()
            if not st or i != st[-1]:
                # 边界情况
                st.append(i)
        return res + len(st) - (st[0] == 0) # 统计最后一个上坡

if __name__ == "__main__":
    s = Solution()
    nums = [3,1,2,1]
    print(s.minOperations(nums))
