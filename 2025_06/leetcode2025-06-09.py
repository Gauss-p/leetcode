class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        # 我们将[1,n]的所有数字按照一个十叉树的方式排列，即每一个数字的子节点就是它乘以10一直到它乘以10再加9
        # 定义一个函数专门计算以x为根节点的子树大小，那么对于每一层，我们都需要计算它的大小，又因为每一个节点的子节点合起来都是连续的数字，所以可以确定出当前层的子节点的最小值和最大值，相减即可得到该层的子节点个数
        # 为了方便计算，我们将最小值和最大值分别保存为x和x+1，为的是如果将最大值直接减去最小值，就可以得到当前层的所有节点个数，而如果切换到下一层，就直接将最小值和最大值分别乘以10即可，相当于在每一个节点的下面都补充上10个节点。例如，对于x=1，如果我们将最小值left置为1，将最大值right置为2，那么当前一层的节点个数就是right-left，接下来切换到下一层，即从10到19，这时候，只需要将left和right都分别乘以10，再次相减，就可以得到20-10=10，正好是10~19的总个数，这样我们就不需要处理最大值以9结尾的问题了。需要注意的是在计算过程中right可能超过n，这时超过部分就不能计算了，所以在统计每一层的有效节点个数的时候，只需要用min(right, n+1)-left的方式即可。
        # 有了计算子树大小的函数，接下来在十叉树中从头开始寻找第k个数字，我们知道，这里面的第k个数字就是这棵树的前序遍历的第k个数字，所以我们从1开始，先向右判断，然后向向下判断，也就是：如果以当前节点为根的子树的大小还小于剩余的节点个数k，我们就直接向右增加当前节点的值，即加1，因为如果整棵子树的大小还凑不够k，再前序遍历也没有任何意义。而如果以当前节点为根的子树大小大于了k，就说明答案存在于当前子树中，那么就开始前序遍历，将当前节点向下增加，即乘以10
        def cnt_subTree_size(x):
            size = 0
            left, right = x, x+1 # 当前层的最大最小值
            while left<=n:
                size += min(right, n+1)-left # min防止right超出最大值n
                left *= 10 # 向下一层计算
                right *= 10
            return size

        cur_node = 1 # 当前节点
        k -= 1
        while k>0:
            cur_size = cnt_subTree_size(cur_node)
            if cur_size-1 < k:
                # 答案不在当前子树中，向右判断
                k = k-((cur_size-1)+1)
                cur_node = cur_node+1
            else:
                # 答案在当前子树中，向下判断
                k -= 1
                cur_node = cur_node*10
        return cur_node

if __name__ == "__main__":
    s = Solution()
    n, k = 13, 2
    print(s.findKthNumber(n, k))
