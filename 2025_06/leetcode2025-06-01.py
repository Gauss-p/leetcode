class Solution:
    def distributeCandies(self, n: int, limit: int) -> int:
        # 用插挡板的方法，首先，如果不考虑limit的限制，要将n个糖果分成三份，就相当于在n+2个空当中插入2个挡板，之所以是n+2，是因为要考虑小朋友没有分到糖果的情况，需要将n个糖果的左右两边的空当都算入，综上，如果不考虑limit，一共有C(n+2, 2)种分法
        # 接下来考虑limit，首先我们要去除有且仅有一个小朋友分到超过limit个糖果的情况，那么假设这个小朋友是A，我们首先先将limit+1个糖果给他，然后再将剩下的(n-(limit+1))个糖果分给三个小朋友，同样用插挡板的方法，可以得到此时有C(n-(limit+1)+2, 2)种分法，又因为三个小朋友都可能分到超过limit个糖果，所以有且仅有一个小朋友分到超过limit个糖果一共有3*C(n-(limit+1)+2, 2)种分法
        # 但是分别减去每个小朋友分到超过limit个糖果的情况会多减掉同时有两个小朋友分到超过limit个糖果的情况，因此我们需要再加上所有的同时有两个小朋友分到超过limit个糖果的情况总数，和只有一个小朋友同理，此时可以先将两个limit+1分给两个小朋友，然后将剩下的糖果再次分给三个小朋友，那么一共有C(n-2*(limit+1)+2, 2)种分法，又因为可能是小朋友AB,AC或BC，所以需要将其乘以3，也就是要再次加上3*C(n-2*(limit+1)+2, 2)种情况
        # 可是如果又加上所有两个小朋友分到超过limit个糖果的情况，就将三个小朋友同时分到超过limit个糖果多算了一次，同理，这个一共有C(n-3*(limit+1)+2, 2)种情况
        # 综上，总情况数就是C(n+2, 2)-3*C(n-(limit+1)+2, 2)+3*C(n-2*(limit+1)+2, 2)-C(n-3*(limit+1)+2, 2)，可以发现这里面所有的组合数第二项都是2，所以我们可以编写一个函数专门计算C(x,2)的值
        # 需要注意的是，如果计算组合数时出现第一项小于0，就需要将组合数计算结果置为0，即，如果x<0，函数返回0
        def comb_n_2(x):
            if x > 0:
                return (x*(x-1))//2
            else:
                return 0
        return comb_n_2(n+2)-3*comb_n_2(n-(limit+1)+2)+3*comb_n_2(n-2*(limit+1)+2)-comb_n_2(n-3*(limit+1)+2)

if __name__ == "__main__":
    s = Solution()
    n = 5
    limit = 2
    print(s.distributeCandies(n, limit))
