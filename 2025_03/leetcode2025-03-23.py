class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        # 如果我们将字符串中的'('看作1，将')'看作-1，那么在一个有效括号字符串中，任意一个前缀和都必须大于等于0
        # 在本题中，我们可以对字符串中的一些字符进行改动，使其前缀和发生变化。我们可以发现一个规律，无论如何，s的所有可能的前缀和奇偶性都相同，并且它们要么是连续奇数要么是连续偶数，因此，我们定义s的前缀和最大值为mx，最小值为mn，只改变这两个值就相当于改变了所有的可能值
        # 举个例子，最极端的情况，如果locked中全部为0，那么对s(长度为4)的所有可能前缀和进行分析：1.对于第一个字符，只能是'('，所以可能的值为1；2.对于前两个字符，因为第二个字符可能是'('或')'，所以此时s的所有可能前缀和就是0或2；3.对于前三个字符，因为第三个字符可能是'('或')'，但是s的前缀和不能为负数，所以此时s的所有可能前缀和就是1或3；对于前四个字符，因为第四个字符可能是'('或')'，所以此时s的所有可能前缀和就是0,2或4
        # 综上，我们可以发现，当locked[i]=0时，s的所有可能前缀和的最大值加1，最小值减1，但是如果最小值减到小于0，那么它上一次一定是0(即为偶数)，所以它应该变成1(变为奇数)。而当locked[i]=1时，如果s[i]='('，最小值和最大值同时加1，否则同时减1，同时要进行对最小值小于0的处理
        # 最后只需要判断最小值是否为0即可，如果为0，就代表可以将s变成有效括号字符串
        n = len(s)
        if n%2 == 1:
            return False
        mn, mx = 0, 0
        for i in range(n):
            if locked[i] == "1":
                # 锁定，mn和mx同加同减
                if s[i] == '(':
                    mn += 1
                    mx += 1
                else:
                    mn -= 1
                    if mn < 0:
                        # 最小值不能小于0
                        mn = 1
                    mx -= 1
                    if mx < 0:
                        return False
            else:
                # 不锁定，最大值加1，最小值减1
                mx += 1
                mn -= 1
                if mn < 0:
                    # 最小值不能小于0
                    mn = 1
        
        return mn==0

if __name__ == "__main__":
    sl = Solution()
    s = "))()))"
    locked = "010100"
    print(sl.canBeValid(s,locked))
