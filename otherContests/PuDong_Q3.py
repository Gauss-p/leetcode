from typing import List

class Solution:
    def lightAdjustment(self, b: List[int]) -> int:
        # 将给出的亮度表看作是一个图像，x轴代表灯的索引，y轴代表灯的亮度。
        # 考虑每一个单调递增和单调递减区间，对于一个单调递增区间，如果要将这个区间内的所有数字全部变成最大的数字，可以想象得到，所需的操作次数就是区间中的最大值减去最小值，那么推广一下，其实将它们全部变成区间内的任何一个数字需要的次数都只是区间最大值减区间最小值，只不过是一部分数字变大一部分数字变小
        # 同时，我们在将一个单调递增区间中的一部分数字变大时，我们可以将和它左侧相邻的一个单调递减的区间中的一部分数字也同时变大，因为我们在增加这些值的过程中也可以顺便带上旁边和当前值相等的一起向上变化，同理，将该单调递增区间中的一部分数字变小时，也可以连带右侧单调递减区间的顶端一部分数字向下变化
        # 因此，如果将所有的单调递增区间全部改变成同一个值，我们也可以将大多数单调递减的区间全部改变成该值，但是要注意的是，如果最后一个单调区间是递减的，那么只有当该递减区间的最小值没有超越之前单增区间的最小值时，它才能被改变成目标值
        # 为了处理上面这个部分灯无法改变的情况，我们还可以采取计算所有单减区间的操作次数的方式，这样也和上面的计算方式同理，在改变某些单减区间时，也可以同样改变其他的单增区间，但是这样的方式也无法计算最右侧单增区间的最大值，如果超出前面所有的最大值，也是无法计算的，但是这两个超出的情况必有一种，因此我们将两种方式分别计算出答案，然后由于超出的情况属于少算，所以我们取求出的两个答案中的最大值，就是最终的答案了
        n = len(b)
        pos, neg = 0, 0 # pos用来记录改变所有单增区间的操作次数，neg用来记录改变所有单减区间的操作次数
        for i in range(n-1):
            cur = b[i+1]-b[i]
            if cur > 0:
                pos += cur
            else:
                neg -= cur
        return max(pos, neg) # 去掉少算的那一个

if __name__ == "__main__":
    s = Solution()
    b = [2,3,3,4,5,2]
    print(s.lightAdjustment(b))
