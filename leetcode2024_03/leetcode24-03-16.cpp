#include <iostream>
#include <vector>
#include <functional>
using namespace std;

class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        int n = grid[0].size(), m = grid.size();
        int res = 0;
        function<void(int, int)> dfs = [&](int row, int col){
            // 如果进入dfs函数，则说明该点可以访问，那么记录此时的最大步数
            res = max(res, col);
            // 如果当前列已为最后一列，那么不需要再循环后一列
            if (col == n-1) return;
            for (int i=max(0, row-1); i<=min(m-1, row+1); i++){
                // 该循环用来往后面走，如果符合规则，那么对符合规则的节点再进行dfs
                if (grid[i][col+1] > grid[row][col]){
                    dfs(i, col+1);
                }
            }
            // 如果访问过，将它标记为0
            grid[row][col] = 0;
        };
        for (int i=0; i<m; i++){
            // 对第一列的每一个数循环，求最大步数
            dfs(i, 0);
        }
        return res;
    }
};

int main(){
    Solution s;
    // vector<vector<int>> grid = {{2,4,3,5},{5,4,9,3},{3,4,2,11},{10,9,13,15}};
    // vector<vector<int>> grid = {{3,2,4},{2,1,9},{1,1,7}};
    // vector<vector<int>> grid = {{1000000,92910,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068},
                                // {1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118}};
    vector<vector<int>> grid = {{187,167,209,251,152,236,263,128,135},{267,249,251,285,73,204,70,207,74},{189,159,235,66,84,89,153,111,189},
                                {120,81,210,7,2,231,92,128,218},{193,131,244,293,284,175,226,205,245}};
    cout << s.maxMoves(grid) << endl;
}
