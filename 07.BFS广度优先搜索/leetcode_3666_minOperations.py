from sortedcontainers import SortedList

class Solution:
    def minOperations(self, s: str, k: int) -> int:
        # 最直接的想法是，从原字符串s开始，每次都在原有的所有情况上进行一次操作，得到新的所有情况，就这样一直操作下去，看过程中是否会出现字符串全部为1的情况，只要在操作过程中出现了全1情况，直接返回此时的操作次数即可。上面所说的进程可以用dfs算法模拟，但在某些情况下可能出现死循环，同时递归基也难以确定，故可以选择BFS的形式，从原字符串s开始，每次操作一次，找到所有可能的结果，存储下来，然后再对这些结果都分别操作一次，继续存储，以此类推，只要在搜索出来的哪一层中出现了全1情况，此时这个层的编号就是答案了
        # 注意到在每次操作中，原字符串中0和1的顺序实际上并没有什么关系，唯一有关系的是0和1的个数，因此在总长度一定的情况下，可以用0的个数来代表每一个状态，这样，在BFS的状态数组中，就可以简单地用一个数字代表一个状态了
        # 首先可以统计出s有start个1，那么这就可以作为BFS的初始条件。接下来看在选择的k个数字中有x个0时，0的个数会怎么变化。首先，如果有x个0被反转，那么0的个数会减少x，同时因为总共选了k个数字，所以有(k-x)个1会被变成0，故而0的个数又会增加(k-x)，所以，如果原先有z个0，在进行如上所述的变换后，0的个数就变成了z-x+(k-x)=z+k-2*x
        # 分析式子z+k-2*x，可以发现无论选取的x是多少，最后得到的结果的奇偶性是相同的，因此可以将可能的0的个数分成两部分，一部分奇数，一部分偶数，这样一来，只要能够确定一次操作中可以得到的0的个数的下限mn和上限mx，就可以直接以2为间隔从mn循环到mx，即可得到所有可能得到的0的情况
        # 以下是优化算法：在BFS的过程中，可能会在不同的操作次数之后得到相同的0的个数，即得到等价的情况，而这时候肯定最好是选操作次数更少的那个情况，故可以对于每一个可能的「0的个数」都提前记录下来，每次第一次找到某个值的时候直接将这个值删除掉，这样如果以后还在这个列表中循环，就可以完美避开之前的所有情况了，这可以减少许多循环
        n = len(s)
        visited = [SortedList(range(0, n+1, 2)), SortedList(range(1, n+1, 2))]
        visited[0].add(n+1) # 添加两个哨兵
        visited[1].add(n+1)

        start = s.count('0')
        visited[start&1].discard(start) # 删除掉最初情况
        res = 0
        q = [start]
        while q:
            cur = []
            for z in q:
                if z == 0:
                    # 0个0，即为全1，就是我们要找的情况
                    return res
                
                # 如果操作中选了x个0，那么在一次操作之后，0的个数就变成了newZ = z+k-2*x
                # 因此newZ的最小值即对应x的最大值，newZ的最大值即对应x的最小值
                # 可以发现x最大可以为min(k, z)，因为最多有z个0，最小可以为max(0, k-(n-z))，因为一共有n-z个1，只有全部将它们选完，才可以选到最少的0
                mn = z+k-2*min(k, z)
                mx = z+k-2*max(0, k-(n-z))

                sl = visited[mn&1]
                indx = sl.bisect_left(mn) # 从下限开始到上限以2为间隔开始循环，每次删除当前情况
                while sl[indx] <= mx:
                    p = sl.pop(indx)
                    cur.append(p)
            q = cur
            res += 1
        return -1

if __name__ == "__main__":
    sl = Solution()
    s = "110"
    k = 1
    print(sl.minOperations(s, k))
