class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        # 本题目是从0开始，每次接续时中间要插1，k指的是第k个字符，相当于原字串秩为k-1的字符        
        # 先找规律：最明显的就是每次续接的时候中间插1，而续接的个数与前面字串相同，也就是按2的幂次进行续接，先来考虑一下中间插1的这个1的位置有什么特点，它所在字串的中秩分别是1, 3, 7,...而按第几个字符来考虑的话，它恰好是第2,4,8,...，是2的幂次
        # 这就启发我们是否可以生成字符串后就得到答案。每一个1后面插入的数恰好都是前面数字倒序后的与自己的异或，得到一个思路，可以用动态规划
        # 我们定义f[i]表示进行n次变换后第i个位置对应的数字，根据题目中构造新字符串的规则，我们可以用2**x到2**(x+1)这个区间来不断地反转前面所有的字符，即，最初我们的字符串应该是0，那它对应的位置区间就是[2**0, 2**1)，接下来，我们的字符串应该是011，那新加入的所有字符对应的位置区间就是[2**1, 2**2)，如果不考虑中间插入的1，新加入的字符对应的位置区间就是(2**1, 2**2)，再接下来，字符串应该是0111001，如果不考虑中间插入的1，新加入的字符对应的区间就应该是(2**2, 2**3)，以此类推，我们就可以用区间(2**n, 2**(n+1))表示第n+1次变换时新加入的字符所在的区间
        # 对于每一个新加入的字符所在的区间，我们可以考虑对称，由于在每一个字符串中，新加入的字符的长度都是总长度的一半，并且是左边一半的所有数字按照中间位置对称过去并翻转得来的，因此，对于(2**n, 2**(n+1))中的任意一个位置i，它对应的数字都应该是它关于2**n位置对称到左边的数字反转得来的，根据这个就可以写出f的状态转移方程：如果2**n<i<2**(n+1)，那么f[i]=1-f[2*(2**n)-i]，其中2*(2**n)-i表示的是i关于2**n对称后的位置
        f = [1]*(k+1)
        f[0] = 1
        f[1] = 0
        lower = 2 # 维护一个2**n，那么当前区间就应该是(lower, lower*2)
        for i in range(2, k+1):
            if lower<i<2*lower:
                f[i] = 1-f[2*lower-i]
            elif i == lower*2:
                # 我们不需要管中间插入的1，是因为初始值全部都是1，如果用两边都开的区间，就不需要考虑中间的接缝位置了
                lower *= 2
        return str(f[k])

        # 也可以用dfs来做。
        # 首先我们分析题目中给出的字符串组成方式，如果每一次让我们求的是整个字符串最中间的数字，那它一定是1，因此我们想到dfs算法，只要一直细分字符串，一直到将k的位置变成当前字符串的最中间的字符，就可以直接返回答案了。
        # 接下来我们需要寻找进行n次变换后的字符串长度的规律，如果变换了1次，即s1的长度就是1，如果变换了两次，即s2的长度就是3，如果变换了3次，即s3的长度就是7，以此类推，可以发现，sn的长度应该是2**n-1，因此它的中间位置就应该是2**(n-1)，因此对于dfs中每一个传入的n，只需要判断k是否等于2**(n-1)即可判断k位置对应的是否为1
        # 所以我们可以对于每一个传入的n，将其转化为一个更小的子问题来计算，假如只变换n-1次，那么字符串一定是当前字符串的左边一半，因此我们可以将k转化为在左边一半对应的下标，然后传入dfs函数再次计算。但是如果k<2**(n-1)，我们直接传入k原值就行，因为它本身就在左半边，k对应的下标直接用原来的即可，而如果k>2**(n-1)，说明k当前位于中点的右边，因此我们需要利用题目中给出的反转规律来计算，即k对应的位置和k关于中点对称后的位置分别对应的两个数字是相反的，因此我们计算对称以后的位置，并将计算出来的答案反转一次即可，因为对称以后下标就在左半边字符串中了
        # 并且还需要注意，如果k是1，单纯靠判断k是否为字符串的中点是无法返回答案的，因此需要特殊判断，如果k=1，那么直接返回答案0即可
        # if k == 1:
        #     return '0'
        # mid = 1<<(n-1)
        # if k == mid:
        #     return '1'
        # elif k < mid:
        #     # 在左半边
        #     return self.findKthBit(n-1, k)
        # else:
        #     # 在右半边，需要取对称
        #     newK = 2*mid-k
        #     res = self.findKthBit(n-1, newK)
        #     if res == '1':
        #         return '0'
        #     else:
        #         return '1'

if __name__ == "__main__":
    s = Solution()
    n = 3
    k = 1
    print(s.findKthBit(n, k))
