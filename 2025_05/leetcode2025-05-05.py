class Solution:
    def numTilings(self, n: int) -> int:
        # 用动态规划的方法，定义dp[i]表示可以平铺2*i面板的方法数量，因此答案就是dp[n]，之后考虑递推关系
        # 我们发现，除了只用多米诺和托米诺，还可以两个混搭使用。在动态规划中，我们只考虑最后的一个块怎么摆放即可，经过观察，可以发现有如下的摆放方式：1.2*1：一个竖着的多米诺；2.2*2：两个横着的多米诺；3.2*3：两个托米诺拼接；4.2*4：两个个托米诺分居左下和右下，中间上方摆一个多米诺；5.两个托米诺分居左上和右下，中间用两个多米诺填充……以此类推可以得到2*任何数的摆放方式，同时我们发现，第3个方法及其之后经过180度旋转后可以成为另一种方法，因此在计算的时候这些方法的数量需要乘以2
        # 将上面的递推关系转换成代码可以得到：dp[i]=dp[i-1]+dp[i-2]+2*dp[i-3]+2*dp[i-4]+...dp[0]，提取出一个2，可以得到dp[i]=dp[i-1]+dp[i-2]+2*(dp[i-3]+dp[i-4]+...+dp[0])，因此定义前缀和数组preSum，其中preSum[i]表示sum(dp[:i+1])，即dp[0]+...+dp[i]，因此dp[i]=dp[i-1]+dp[i-2]+2*preSum[i-3]
        # 注意初始值，dp[0]应有一种排列方法
        if n == 1 or n == 2:
            return n

        modNum = 1_000_000_007
        dp = [0]*(n+1) # 动态规划数组
        preSum = [0]*(n+1)
        dp[:3] = [1,1,2]
        preSum[:3] = [1,2,4]

        for i in range(3,n+1):
            dp[i] = dp[i-1]+dp[i-2]+2*preSum[i-3] # 递推
            preSum[i] = preSum[i-1]+dp[i]
        return dp[n]%modNum

if __name__ == "__main__":
    s = Solution()
    n = 4
    print(s.numTilings(n))
