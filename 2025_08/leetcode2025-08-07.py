from typing import List

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        # 首先分析题目，看从(0,0)出发的小朋友，可以发现无论怎样走，这个小朋友也只能够走对角线，因为这道题目有步数限制，从(0,0)走到(n-1,n-1)，就是向量(n-1,n-1)，又因为最多只能走n-1步，所以平均每次走的向量就是(1,1)，也就是说，如果要在步数限制内走，这个小朋友只能选择(i+1,j+1)的走法，因此接下来我们就不考虑这个小朋友，只考虑剩下两个即可
        # 对于从(0,n-1)开始走的小朋友，分析他每一步的选择方式，可以发现，每一步他都要往下走一行，也就是说，我们只需要考虑下一步往那一列走即可，因此定义动态规划数组f，其中f[i][j]表示这个小朋友走到(i,j)位置可以得到的最大水果数目，其中任意一个(i,j)位置都可以从(i-1, j-1)和(i-1, j)转移过来，但是当且仅当j+1没有超过n的限制的时候我们才能将他从(i-1, j+1)转移过来，因此，我们可以得到状态转移方程：f[i][j] = max(f[i-1][j-1], f[i-1][j], (f[i-1][j+1] if j+1<n))，这样，直接计算到底即可。但是我们可以发现，如果在转移过程中该小朋友越过了主对角线，那么由于他每一步只能够向右移动一个位置，所以这时他就再也不可能到达终点(n-1, n-1)了，因此，我们需要在循环的时候，对于每一个i，限制j>i
        # 那么同理，我们也可以知道从(n-1,0)开始走的小朋友到达任意一个点的可收集水果的最大数量，由于根据限制可以知道，两者在位置上不可能出现重叠，因此我们可以用一个列表来计算这两个小朋友的信息
        # 需要注意的是，动态规划列表的初始值应当设置为-inf，因为在循环的时候，如果设置为0，可能出现错误计算的情况，导致计算出一个不存在的路径，只有-inf加上任何一个值也不可能变成正值
        n = len(fruits)
        f = [[-float("inf")]*n for _ in range(n)]

        f[0][n-1] = fruits[0][n-1] # 起点的值应当相等
        for i in range(1, n):
            for j in range(i+1, n):
                if j < n//2:
                    continue
                f[i][j] = max(f[i-1][j-1], f[i-1][j]) # 两个一定可以转移的位置
                if j+1<n:
                    f[i][j] = max(f[i][j], f[i-1][j+1])
                f[i][j] += fruits[i][j] # 加上当前位置的水果数量
        
        f[n-1][0] = fruits[n-1][0] # 同样的计算方式
        for j in range(1, n):
            for i in range(j+1, n):
                if i<n//2:
                    continue
                f[i][j] = max(f[i-1][j-1], f[i][j-1])
                if i+1<n:
                    f[i][j] = max(f[i][j], f[i+1][j-1])
                f[i][j] += fruits[i][j]

        res = 0
        for i in range(n): # 最后直接计算第一个小朋友，沿着对角线走即可
            res += fruits[i][i]
        # 注意，计算答案的时候，由于我们在之前考虑了限制，因此不可能计算(n-1, n-1)点的答案，又因为这里只能计算一次，所以直接用刚才计算出来的对角线上的最后一个点即可
        return res+f[n-1][n-2]+f[n-2][n-1]

if __name__ == "__main__":
    s = Solution()
    fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]
    print(s.maxCollectedFruits(fruits))
