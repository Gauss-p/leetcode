from typing import List

# 首先，题目要求分成的三个数组都是子序列，因此我们可以想到用一个长度为n的二进制数字中的每一个位置来代表该位置上选或不选，因此，我们可以先来求nums中所有子序列的按位异或和按位与的结果，然后，由于A和C都是要按位异或的，因此我们可以先遍历所有可能的B，然后再剩下的所有数字中分成两部分来计算异或最大和
# 因此，我们先计算所有子序列按位异或和按位与的结果，可以知道，如果总长度是n，那么子序列就一共有2**n种可能，因此我们用数组arrXor来计算所有子序列的异或和，并用arrAnd来计算所有子序列的按位与值。这里我们可以考虑动态规划的算法，首先，从头到尾循环每一个位置i，对于当前位置i，我们如果选择，就说明在二进制中会多出一个1<<i，因此，对于最高位是第i位并且该位置是1的所有二进制数字我们都需要进行计算，但是注意，由于我们是按照二进制位从低到高依次计算的，因此要计算上述的所有情况，其实可以考虑前i-1个二进制位的所有可能的情况，然后对于每一种情况，都在二进制的最高位之前再加上一个1，就可以得到所有可能的值了，但是这样只得到了对应的索引，我们还需要在两个数组中分别求出加上第i个数字的异或和以及按位与值，即可完成
# 那么接下来我们只需要对于每一个可能的B求出该情况下的最大XOR(A)+AND(B)+XOR(C)，然后将每一种情况求最大值即可。首先，对于当前循环到的B的组成方式state，可以直接用arrAnd[state]来得到表达式中的AND(B)，然后A和C只需在state中没有被选中的位置中瓜分即可。对于每一种瓜分方式，我们都需要求XOR(A)+XOR(C)的最大值
# 因此我们考虑每一个二进制位，对于异或，一个二进制位上是否为1，取决于参与异或运算中该位置上是1的数字总个数。总个数有两种情况：1.如果总个数是奇数，那么我们要将它分成两部分，无论如何也只能分成一个偶数加一个奇数，又因为偶数个1异或后是0，奇数个1异或后是1，所以A和C无论怎样分配，最终异或后加出来的答案在这个二进制位上一定是1；2.如果总个数是偶数，那么我们要将它分成两部分，就可能分成两个偶数或两个奇数，对于两个偶数的分法，A和C在异或后这一位上都是0，对于两个奇数的分法，A和C在异或后这一位上都是1，但是注意，我们不可能在所有总数为偶数的二进制位置上都选择两个奇数的分法，尽管这样加出来最大，可是保证了一个位置是两个奇数就无法保证另外一些位置是奇数，所以我们只能这样考虑，由于每个出现次数为偶数的位置分成两部分后进行异或都是相等的，也就是说A和C在这个位置上异或后相同，因此如果将A和C中的每一个数字都去除掉出现总数为奇数的位置，得到新的两个数组A'和C'，那么xor(A')=xor(C')，也就是xor(A')+xor(C')=2*xor(A')，因此我们只需要找出在去除出现总数为奇数的二进制位后的所有数中，最大的子数组异或和乘以2即可
# 经过以上的分析，对于nums去除B后的所有数字，考虑一个二进制位，如果剩余数字中该二进制位上是1的个数为奇数，那么XOR(A)+XOR(C)得到的数字在该二进制位上会保留1，而如果将所有的剩余数字都进行异或，得到的值中任意一个是1的二进制位在剩余数字中出现次数其实都是奇数，因此将所有剩余数字进行异或，即可得到出现奇数次的二进制位的计算结果。接下来，对于所有数字去除上述出现奇数次的二进制位，剩下的就是出现偶数次的二进制位，然后求去除后的所有数字中子序列最大异或和乘以2即可得到最大总和
# 于是问题转换成了求一些数字中子序列的最大异或和。这里我们可以用异或基的方式来求，由于异或的过程中可能出现某一些数字进行异或运算之后正好得出了数组中的另一个数，这样如果在之后的运算中又计算该数字，就会出现重复，因此我们可以考虑只存储那些无法通过其他一些数字运算出来的基本数字，因此，我们将所有的二进制位排列开，在插入一个数字x的时候，我们要判断，这个数字是否可以用其他数字异或来表示，因此取出该数字的最高二进制位，如果该位置之前有保存值，就将两个数字异或，从而去除x的最高位，以此类推，直到x减小至某一个程度，使得x的最高位没有保存值，我们就将减小后的x存入，而如果x一直到0都没有这种情况出现，就说明x可以通过已经保存的一些值异或出来，不用将它加入
# 求出所有的异或基后，我们直接对异或基进行计算子数组最大异或值即可，因为它们互不重叠，不会出现重复计算的情况，这样就简单了
# 综上，我们只需对任意一个情况B，计算：AND(B)+XOR(剩余数中出现次数为奇数的位)+2*max(XOR(剩余数去除奇数次出现的二进制位后的任意一个子数组))即可，即AND(B)+X+2*max(xor(A'))

class xorBase:
    def __init__(self, n):
        self.b = [0]*n # 每一个数位上的基
        self.n = n
    
    def insert(self, x):
        while x:
            i = x.bit_length()-1
            if self.b[i] == 0:
                # 只有该位置没有保存过值才能将它保存
                self.b[i] = x
                return
            x ^= self.b[i]
    
    def max_Xor(self):
        res = 0
        for i in range(self.n-1, -1, -1):
            if res < res^self.b[i]:
                # 只要能增大res，就进行异或
                res ^= self.b[i]
        return res

class Solution:
    def maximizeXorAndXor(self, nums: List[int]) -> int:
        n = len(nums)
        sz = max(nums).bit_length() # 求出最高二进制位，用来确定异或基中b的大小
        arrXor = [0]*(1<<n)
        arrAnd = [-1]*(1<<n) # 因为-1的二进制是1所有位取反再加1，也就是全部为1，所以AND任何数都不会有影响
        for i, x in enumerate(nums):
            high = 1<<i # 按照最高位进行计算
            for mask in range(high):
                arrXor[high|mask] = arrXor[mask]^x
                arrAnd[high|mask] = arrAnd[mask]&x

        def getMaxXor(state):
            xb = xorBase(sz)
            for i, a in enumerate(nums):
                if (state>>i)&1 == 0: # 只有B没有选择该数字，该数字才能进行计算
                    xb.insert(a&(~X)) # 去除出现奇数次的位置
            return xb.max_Xor()

        X = 0
        res = 0
        for state in range(1<<n):
            X = arrXor[(1<<n)-1]^arrXor[state] # 用异或去除所有的B中元素，即可得到剩余所有元素的异或
            curAns = arrAnd[state]+X+2*getMaxXor(state) # 带入公式
            res = max(res, curAns) # 记录答案
        return res

if __name__ == "__main__":
    s = Solution()
    nums = [2, 3]
    print(s.maximizeXorAndXor(nums))
