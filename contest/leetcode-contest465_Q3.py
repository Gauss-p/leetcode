from typing import List

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # 对于这个问题，最直观的想法就是：只要两个数相与等于0，就将它们相乘并计入答案。那么对于任意一个数字a，想要找到和它相与等于0的数字，可以直接用所有位置上都是1的数字和它进行异或，记得到的数字为b，计算结果就是我们要的数字。但是如果这个数字并没有在nums中出现怎么办？可以发现，只要一个数字所有是1的二进制位是b所有是1的二进制位的子集，那么这个数字和a相与一定可以得到0，也就是说，我们需要找b的二进制位中是1的位置的子集，对于所有的子集判断其是否在nums中出现过，如果出现，那么就可以将它列为备选，最后取所有备选的最大值即可
        # 举个例子，如果b的二进制是1011，那么它的二进制位中是1的位置的子集就有：0011, 1001, 1010, 0001, 1000, 0010，然后对于在nums中出现过的数字求最大值即可
        # 为了求出一个数字的二进制位中是1的位置的所有子集，我们可以用动态规划的方式：定义f[x]表示：对于数字x，其二进制位中是1的位置的子集中，出现在nums中数字的最大值。那么对于x，我们只选择其二进制中的一个1，删除后将剩余的数字在f中对应的数字和f[x]取最大值即可，这样，又因为剩余的数字也是按照这样求出来的，所以f[x]就可以对所有的子集进行判断
        # 那么f数组的初始值就应当这样设置：将nums中所有数字在f中都设置为当前数字，也就是对于nums中的任意一个数字i，都执行f[i]=i，这样就可以从基础开始计算了
        maxPos = len(bin(max(nums)))-2
        f = [0]*(1<<maxPos)
        for i in nums: # 初始化
            f[i] = i
        
        for i in range(maxPos):
            u = 1<<i
            for s in range(1<<maxPos):
                if s&u: # 注意这里只有当此时要计算的值中当前位置是1时，才进行计算，否则会超时
                    if f[s^(1<<i)] > f[s]:
                        f[s] = f[s^(1<<i)]

        mask = (1<<maxPos)-1
        res = 0
        for v in nums:
            cur = v*f[v^mask]
            if cur>res:
                res = cur
        return res

if __name__ == "__main__":
    s = Solution()
    nums = [1,2,3,4,5,6,7]
    print(s.maxProduct(nums))
